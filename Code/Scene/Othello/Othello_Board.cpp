#include"DxLib.h"
#include"windows.h"
#include <string.h>
#include "./../Code/GetKey.h"
#include "./Othello_Board.h"
#include "./Othello_Player.h"

Othello_Board* OB;

// 初期化
void Othello_Board::Othello_Board_Initialize() {
	//Board = LoadGraph("Resource/image/Othello_Board.jpg");

    BlackCr = GetColor(0, 0, 0);        // 黒色を設定
    GreenCr = GetColor(0, 255, 0);      // 緑色を設定
    WhiteCr = GetColor(255, 255, 255);  // 白色を設定

    OrderNum = 0;   // 0 = 黒石、 1 = 白石
    BlackNum = 0;
    WhiteNum = 0;
    TimeCount = 0;
    ReturnNum = 0;
    ReturnNumMax = 0;

    DrawFlag = false;
    CheckFlag = false;
    PassFlag = false;
    EndFlag = false;

    Init_OthelloBoard(Board);           // ボードを初期化
    
}

// 終了処理
void Othello_Board::Othello_Board_Finalize() {
	//DeleteGraph(Board);
}

// 更新
void Othello_Board::Othello_Board_Update() {

    if (PassFlag == false) {    // パスをするフラグが false なら
        if (OrderNum == 0) {    // 手番が黒なら
            DrawFormatString(650, 90, WhiteCr, "左クリック：黒の番です");
        }
        else {      // 手番が白なら
            DrawFormatString(650, 90, WhiteCr, "左クリック：白の番です");
        }
    }
    else {      // パスをするフラグが true なら
        DrawFormatString(650, 90, WhiteCr, "パス！");      // パス！と表示する
        TimeCount++;
        // 1秒経ったら
        if (TimeCount >= 60)
        {
            TimeCount = 0;      // TimeCount を初期化

            // 黒の手番なら白の手番にして、白の手番なら黒の手番にする
            if (OrderNum == 0) 
            {
                OrderNum = 1;
            }
            else 
            {
                OrderNum = 0;
            }
            PassFlag = false;   // パスフラグを false にする
        }
    }
    // デバッグ用
    DrawFormatString(650, 140, WhiteCr, "黒石:%d", BlackNum);
    DrawFormatString(650, 190, WhiteCr, "白石:%d", WhiteNum);
    DrawFormatString(650, 240, WhiteCr, "TimeCount:%d", TimeCount);
    DrawFormatString(1000, 240, WhiteCr, "BoardX:%d", Board_X);
    DrawFormatString(1000, 290, WhiteCr, "BoardY:%d", Board_Y);
    DrawFormatString(1000, 340, WhiteCr, "ReturnNumMax:%d", ReturnNumMax);





    GetMousePoint(&Mouse_X, &Mouse_Y);  // マウスカーソルの位置を取得
    Square_X = Mouse_X / MAP_SIZE;      // マウスカーソルの位置を MAP_SIZE で割った値を代入
    Square_Y = Mouse_Y / MAP_SIZE;      // マウスカーソルの位置を MAP_SIZE で割った値を代入

    if (EndFlag == false) {   // ゲームが終わったかどうか
        if (PassFlag == false) {    // パスフラグが false なら
            if (OrderNum == 0) {    // 黒の番だったら

                // 黒石の置ける場所がないなら
                if (!BoardSearchBlack(Board))
                {
                    PassFlag = true;    // パスフラグを true にする
                }

                if (Board[Square_X][Square_Y] == 3) {   // 黒石が置ける場所にカーソルがあっていたら
                    DrawFlag = true;
                    if (key->GetKeyState(REQUEST_MOUSE_LEFT) == KEY_PUSH) { // 左クリックしたら
                        DrawFlag = false;
                        Board[Square_X][Square_Y] = 1;      // 黒石を置く
                        BlackPut();                         // 置いた場所から白を黒にひっくり返す
                        OrderNum = 1;                       // 白の手番にする
                        BoardSearchBWNumber(Board);         // 黒石と白石の数を数える関数実行
                        if (EndGame(Board)) {               // ゲームが終わる条件を満たしたら
                            EndFlag = true;   // エンドフラグを true にする
                        }
                        DrawFlag = false;
                        // ReturnNumMax = 0;
                    }

                }
                else {
                    DrawFlag = false;
                }
            }
            else {      // 白の番だったら

                if (!BoardSearchWhite(Board)) {
                    PassFlag = true;
                    //OrderNum = 0;
                }

                if (TimeCount++ >= 60) {
                    TimeCount = 0;
                    ReturnNumWhite(Board);
                    OrderNum = 0;
                }

                BoardSearchBWNumber(Board);
                if (EndGame(Board)) {
                    EndFlag = true;
                }

                // ------------自分で白石を置くよう-----------------------------
                //if (Board[Square_X][Square_Y] == 4) {   // 白石が置ける場所にカーソルがあっていたら
                //    DrawFlag = true;
                //    if (key->GetKeyState(REQUEST_MOUSE_LEFT) == KEY_PUSH) { // 左クリックしたら
                //        Board[Square_X][Square_Y] = 2;      // 白石を置く
                //        WhitePut();     // 置いた場所から黒を白にひっくり返す
                //        OrderNum = 0;   // 黒の手番にする
                //        BoardSearchBWNumber(Board);
                //        if (EndGame(Board)) {
                //            EndFlag = true;
                //        }
                //    }
                //}
                //else {
                //    DrawFlag = false;
                //}
                // ----------------------------------------------
            }
        }
    }
}


// 描画
void Othello_Board::Othello_Board_Draw() {
    //DrawBox(0, 0, 1280, 720, GetColor(255, 255, 255), TRUE);
    Print_OthelloBoard(Board);      // オセロボードの描画

    if (PassFlag == false) {
        if (OrderNum == 0) {    // 黒の番だったら
            BoardSearchBlack(Board);    // 黒石が置ける場所を描画する
        }
        else {                  // 白の番だったら
            BoardSearchWhite(Board);    // 白石が置ける場所を描画する
        }
    }
    if (EndFlag == true) {
        DrawFormatString(650, 400, WhiteCr, "ゲーム終了！");
        DrawFormatString(650, 500, WhiteCr, "3秒後にリセットします");
        if (WhiteNum < BlackNum) {
            DrawFormatString(650, 450, WhiteCr, "黒の勝ち！");
            if (TimeCount++ >= 180) {
                TimeCount = 0;
                BlackNum = 0;
                WhiteNum = 0;
                EndFlag = false;
                Init_OthelloBoard(Board);
            }
        }
        else if (BlackNum < WhiteNum) {
            DrawFormatString(650, 450, WhiteCr, "白の勝ち！");
            if (TimeCount++ >= 180) {
                TimeCount = 0;
                BlackNum = 0;
                WhiteNum = 0;
                EndFlag = false;
                Init_OthelloBoard(Board);
            }
        }
    }

}

// ボードを初期化する
void Othello_Board::Init_OthelloBoard(int board[PB][PB]) {
static int InitBoard[PB][PB] =
{
 {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1,  0,  0,  0,  2,  1,  0,  0,  0, -1},
 {-1,  0,  0,  0,  1,  2,  0,  0,  0, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
 {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};
memcpy(board, InitBoard, sizeof(InitBoard));
}

// ボードを表示する
void Othello_Board::Print_OthelloBoard(int board[PB][PB]) {
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if (board[i][j] == 0) {
                // ボードのマス目を見やすくするために黒色で囲む
                DrawBox(i * MAP_SIZE, j * MAP_SIZE,
                    (i * MAP_SIZE) + MAP_SIZE, (j * MAP_SIZE) + MAP_SIZE, WhiteCr, TRUE);

                // ボードのマスの設定
                DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                    (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GreenCr, TRUE);

            }
            if (board[i][j] == 1) {
                // ボードのマス目を見やすくするために黒色で囲む
                DrawBox(i * MAP_SIZE, j * MAP_SIZE,
                    (i * MAP_SIZE) + MAP_SIZE, (j * MAP_SIZE) + MAP_SIZE, WhiteCr, TRUE);

                // ボードのマスの設定
                DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                    (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GreenCr, TRUE);

                // 黒石を置く
                DrawCircle(i * MAP_SIZE + (MAP_SIZE / 2), j * MAP_SIZE + (MAP_SIZE / 2), 27, BlackCr, TRUE);
            }
            if (board[i][j] == 2) {
                // ボードのマス目を見やすくするために黒色で囲む
                DrawBox(i * MAP_SIZE, j * MAP_SIZE,
                    (i * MAP_SIZE) + MAP_SIZE, (j * MAP_SIZE) + MAP_SIZE, WhiteCr, TRUE);

                // ボードのマスの設定
                DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                    (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GreenCr, TRUE);

                // 白石を置く
                DrawCircle(i * MAP_SIZE + (MAP_SIZE / 2), j * MAP_SIZE + (MAP_SIZE / 2), 27, WhiteCr, TRUE);
            }
            if (board[i][j] == 3) {
                // ボードのマス目を見やすくするために黒色で囲む
                DrawBox(i * MAP_SIZE, j * MAP_SIZE,
                    (i * MAP_SIZE) + MAP_SIZE, (j * MAP_SIZE) + MAP_SIZE, WhiteCr, TRUE);

                // ボードのマスの設定
                DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                    (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GreenCr, TRUE);

                CursorOn_OthelloBoard();    // マウスカーソルの位置がボードのマス目の上に来たマスを赤く表示する
            }
            if (board[i][j] == 4) {
                // ボードのマス目を見やすくするために黒色で囲む
                DrawBox(i * MAP_SIZE, j * MAP_SIZE,
                    (i * MAP_SIZE) + MAP_SIZE, (j * MAP_SIZE) + MAP_SIZE, WhiteCr, TRUE);

                // ボードのマスの設定
                DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                    (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GreenCr, TRUE);

                CursorOn_OthelloBoard();    // マウスカーソルの位置がボードのマス目の上に来たマスを赤く表示する
            }
        }
    }
}

// マウスカーソルの位置がボードのマスの上に来たマスを赤く表示する
void Othello_Board::CursorOn_OthelloBoard() {
    if (DrawFlag == true)
    {
        DrawBox((Square_X * MAP_SIZE) + 1, (Square_Y * MAP_SIZE) + 1,
            (Square_X * MAP_SIZE) + MAP_SIZE - 1, (Square_Y * MAP_SIZE) + MAP_SIZE - 1, GetColor(255, 0, 0), TRUE);
    }
}

/*
* 1.置けるところを探す
* 2.置けるところに石を置く
* 3.石をひっくり返す
*/

// プレイヤーの石で相手の石を挟むと自分の石の色に変える(ボード、左右、上下、敵の色、プレイヤーの色）
int Othello_Board::CursorPutOnCheck(int board[PB][PB], int p, int q, int enemy, int player) {

    int count = 0;  // CheckNum の値を入れる用変数

    // 調べた方向に対して敵の石があったら
    if (board[Square_X + p][Square_Y + q] == enemy) {

        // カーソルが合っているところから、置いた場合プレイヤーの石があるかどうか調べる
        for (CheckNum = 1; board[Square_X + CheckNum * p][Square_Y + CheckNum * q] != player; CheckNum++) {

            // 調べた方向に空いているマスがあったら
            if (board[Square_X + CheckNum * p][Square_Y + CheckNum * q] == 0 ||
                board[Square_X + CheckNum * p][Square_Y + CheckNum * q] == -1) {
                return 0;
            }
        }


        // 調べた方向に対して player が置いてあるマスから逆順に辿って、プレイヤーが置いた場所まで戻るまで
        for (count = CheckNum - 1; board[Square_X + count * p][Square_Y + count * q] != player; count--) {

            // 調べたところが、0, 3, 4, -1 のいずれかなら return 0
            if (board[Square_X + count * p][Square_Y + count * q] == 0 ||
                board[Square_X + count * p][Square_Y + count * q] == 3 ||
                board[Square_X + count * p][Square_Y + count * q] == 4 ||
                board[Square_X + count * p][Square_Y + count * q] == -1) {
                return 0;
            }
        }
        // 調べた方向に対して、 もう一度逆順に辿って player の石にひっくり返す
        for (CheckNum = CheckNum - 1; board[Square_X + CheckNum * p][Square_Y + CheckNum * q] != player; CheckNum--) {
            // 調べたマスが enemy のマスだったら
            if (board[Square_X + CheckNum * p][Square_Y + CheckNum * q] == enemy) {
                board[Square_X + CheckNum * p][Square_Y + CheckNum * q] = player;   // player の石にひっくり返す
            }
        }
    }
    return 1;
}


int Othello_Board::PutOnCheck(int board[PB][PB], int p, int q, int d, int e, int enemy, int player) {

    int count = 0;  // CheckNum の値を入れる用変数
    ReturnNum = 0;

    // 調べた方向に対して敵の石があったら
    if (board[d + p][e + q] == enemy) {

        // 置いた場合、指定した方向にプレイヤーの石があるかどうか調べる
        for (CheckNum = 1; board[d + CheckNum * p][e + CheckNum * q] != player; CheckNum++) {

            // 調べた方向に空いているマスがあったら
            if (board[d + CheckNum * p][e + CheckNum * q] == 0 ||
                board[d + CheckNum * p][e + CheckNum * q] == -1) {
                return 0;
            }
        }


        // 調べた方向に対して player が置いてあるマスから逆順に辿って、プレイヤーが置いた場所まで戻るまで
        for (count = CheckNum - 1; board[d + count * p][e + count * q] != player; count--) {

            // 調べたところが、0, 3, 4, -1 のいずれかなら return 0
            if (board[d + count * p][e + count * q] == 0 ||
                board[d + count * p][e + count * q] == 3 ||
                board[d + count * p][e + count * q] == 4 ||
                board[d + count * p][e + count * q] == -1) {
                return 0;
            }
        }



        // 調べた方向に対して、 もう一度逆順に辿って player の石にひっくり返す
        for (CheckNum = CheckNum - 1; board[d + CheckNum * p][e + CheckNum * q] != player; CheckNum--) {
            // 調べたマスが enemy のマスだったら
            if (board[d + CheckNum * p][e + CheckNum * q] == enemy) {
                board[d + CheckNum * p][e + CheckNum * q] = player;   // player の石にひっくり返す
                ReturnNum++;
            }
        }
    }
    return ReturnNum;
}


// 黒石を置いた位置から、挟んで変えられる白石を探して黒石に変える
int Othello_Board::BlackPut() {
    CursorPutOnCheck(Board, 1, 0, 2, 1);
    CursorPutOnCheck(Board, -1, 0, 2, 1);
    CursorPutOnCheck(Board, 0, 1, 2, 1);
    CursorPutOnCheck(Board, 0, -1, 2, 1);
    CursorPutOnCheck(Board, 1, 1, 2, 1);
    CursorPutOnCheck(Board, -1, 1, 2, 1);
    CursorPutOnCheck(Board, 1, -1, 2, 1);
    CursorPutOnCheck(Board, -1, -1, 2, 1);

    //if (CursorPutOnCheck(Board, -1,  0, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board,  0,  1, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board,  0, -1, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board,  1,  1, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board, -1,  1, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board,  1, -1, 2, 1)) return 1;
    //if (CursorPutOnCheck(Board, -1, -1, 2, 1)) return 1;

    return 0;
}

// 白石を置いた位置から、挟んで変えられる黒石を探して白石に変える
int Othello_Board::WhitePut() {
    CursorPutOnCheck(Board, 1, 0, 1, 2);
    CursorPutOnCheck(Board, -1, 0, 1, 2);
    CursorPutOnCheck(Board, 0, 1, 1, 2);
    CursorPutOnCheck(Board, 0, -1, 1, 2);
    CursorPutOnCheck(Board, 1, 1, 1, 2);
    CursorPutOnCheck(Board, -1, 1, 1, 2);
    CursorPutOnCheck(Board, 1, -1, 1, 2);
    CursorPutOnCheck(Board, -1, -1, 1, 2);

    //if (CursorPutOnCheck(Board, 1, 0, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, -1, 0, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, 0, 1, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, 0, -1, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, 1, 1, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, -1, 1, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, 1, -1, 1, 2)) return 1;
    //if (CursorPutOnCheck(Board, -1, -1, 1, 2)) return 1;

    return 0;
}

int Othello_Board::WhitePutCPU(int d, int e) {
    PutOnCheck(Board,  1,  0, d, e, 1, 2);
    PutOnCheck(Board, -1,  0, d, e, 1, 2);
    PutOnCheck(Board,  0,  1, d, e, 1, 2);
    PutOnCheck(Board,  0, -1, d, e, 1, 2);
    PutOnCheck(Board,  1,  1, d, e, 1, 2);
    PutOnCheck(Board, -1,  1, d, e, 1, 2);
    PutOnCheck(Board,  1, -1, d, e, 1, 2);
    PutOnCheck(Board, -1, -1, d, e, 1, 2);

    return 0;
}

// 左右上斜めに石があるかどうか調べる
int Othello_Board::BlackPutCheck(int d, int e) {

    if (PutSearch(Board, 1, 0, d, e, 2, 1)){    // 右
        return 1;
    }
    if (PutSearch(Board, -1, 0, d, e, 2, 1)) {  // 左
        return 1;
    }
    if (PutSearch(Board, 0, -1, d, e, 2, 1)) {  // 上
        return 1;
    }
    if (PutSearch(Board, 0, 1, d, e, 2, 1)) {   // 下
        return 1;
    }

    if (PutSearch(Board, 1, 1, d, e, 2, 1)) {   // 右下
        return 1;
    }
    if (PutSearch(Board, -1, 1, d, e, 2, 1)) {  // 左下
        return 1;
    }
    if (PutSearch(Board, 1, -1, d, e, 2, 1)) {  // 右上
        return 1;
    }
    if (PutSearch(Board, -1, -1, d, e, 2, 1)) { // 左上
        return 1;
    }

    return 0;
}

int Othello_Board::WhitePutCheck(int d, int e) {

    if (PutSearch(Board, 1, 0, d, e, 1, 2)) {    // 右
        return 1;
    }
    if (PutSearch(Board, -1, 0, d, e, 1, 2)) {  // 左
        return 1;
    }
    if (PutSearch(Board, 0, -1, d, e, 1, 2)) {  // 上
        return 1;
    }
    if (PutSearch(Board, 0, 1, d, e, 1, 2)) {   // 下
        return 1;
    }

    if (PutSearch(Board, 1, 1, d, e, 1, 2)) {   // 右下
        return 1;
    }
    if (PutSearch(Board, -1, 1, d, e, 1, 2)) {  // 左下
        return 1;
    }
    if (PutSearch(Board, 1, -1, d, e, 1, 2)) {  // 右上
        return 1;
    }
    if (PutSearch(Board, -1, -1, d, e, 1, 2)) { // 左上
        return 1;
    }

    return 0;
}

// 8方向を調べて石が無ければ return 0 、石があれば return 1 を返す
int Othello_Board::PutSearch(int board[PB][PB], int p, int q, int d, int e, int enemy, int player) {
    int i;

    // 指定した方向に enemy（敵の石) があったら
    if (board[d + p][e + q] == enemy) {

        // 指定した方向に -1 がある所まで調べる
        for (i = 1; board[d + i * p][e + i * q] != -1; i++) {

            // 指定した方向の途中に board[][] == 0 or 3 or 4 があったら return 0
            if (board[d + i * p][e + i * q] == 0 ||
                board[d + i * p][e + i * q] == 3 ||
                board[d + i * p][e + i * q] == 4 ) {
                return 0;
            }

            // 指定した方向の途中に board[][] == player があったら return 1 を返す
            if (board[d + i * p][e + i * q] == player) {
                return 1;
            }
        }
    }
    return 0;   // 指定した方向に敵の石が無かったら return 0
}

//黒石が置ける場所を探す
int Othello_Board::BoardSearchBlack(int board[PB][PB]) {
    int blackcount = 0;  // 黒石が置ける場所を数える用変数

    // マップチップを探索
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            // 白石と黒石が置ける場所を初期化
            if (board[i][j] == 3 || board[i][j] == 4) {
                board[i][j] = 0;
            }

            // 何も置かれてない場所だったら
            if (board[i][j] == 0) {
                if (BlackPutCheck(i, j)) {  // 黒石が置ける場所があったら

                    DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                        (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GetColor(100, 0, 0), false);

                    board[i][j] = 3;    // 黒石が置けるようにする
                    blackcount++;       // 黒石が置ける場所の数だけインクリメント

                }

            }
        }
    }

    // 黒石が置ける場所が無かったら、パスする
    if (blackcount == 0) {
        return 0;
    }
    return 1;
}

//白石が置ける場所を探す
int Othello_Board::BoardSearchWhite(int board[PB][PB]) {
    int whitecount = 0;     // 白石が置ける場所を数える用変数

    // マップチップを探索
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            // 白石と黒石を置ける場所を初期化
            if (board[i][j] == 4 || board[i][j] == 3) {
                board[i][j] = 0;
            }

            // 何も置かれていない場所なら
            if (board[i][j] == 0) {
                if (WhitePutCheck(i, j)) {  // 白石が置ける場所があったら

                    // 置ける場所を分かりやすくするために囲む
                    DrawBox((i * MAP_SIZE) + 1, (j * MAP_SIZE) + 1,
                        (i * MAP_SIZE) + MAP_SIZE - 1, (j * MAP_SIZE) + MAP_SIZE - 1, GetColor(100, 0, 0), false);

                    board[i][j] = 4;    // 白石が置けるようにする
                    whitecount++;       // 白石が置ける場所の数だけインクリメント
                }
            }
        }
    }

    // 白石が置ける場所が無かったら、パスする
    if (whitecount == 0) {
        return 0;
    }
    return 1;
}

// 黒石と白石の数を調べる
void Othello_Board::BoardSearchBWNumber(int board[PB][PB]) {
    BlackNum = 0;   // 黒石の数を初期化
    WhiteNum = 0;   // 白石の数を初期化

    // マップチップを順に探索
    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if (board[i][j] == 1) {     // 黒石のマスだったら
                BlackNum++; // 黒石の数を増やす
            }

            if (board[i][j] == 2) {     // 白石のマスだったら
                WhiteNum++; // 白石の数を増やす
            }
        }
    }
}


// ゲームが終わる条件を満たしていたら、終了する処理(仮)
int Othello_Board::EndGame(int board[PB][PB]) {

    // 黒石と白石、両方とも置くところがなくなったら
    if (!BoardSearchBlack(Board)) {
        if (!BoardSearchWhite(Board)) {
            return 1;
        }
    }

    // 黒石と白石で盤面が埋まったら
    if (WhiteNum + BlackNum == 64) {
        return 1;
    }

    return 0;
}


// CPU（仮）
int Othello_Board::ReturnNumWhite(int board[PB][PB]) {
    //board[Board_X][Board_Y] = 2;
    //WhitePutCPU();
    // マップチップを使ってみる
    // PutOnSearchを改良してみる

    for (int i = 1; i <= 8; i++) {
        for (int j = 1; j <= 8; j++) {
            if (board[i][j] == 4) {
                // 置けるマスのひっくり返せる数を調べたい
                if (ReturnNumMax < ReturnNum) {
                    ReturnNumMax = ReturnNum;
                    Board_X = i;
                    Board_Y = j;
                }

            }
        }
    }
    board[Board_X][Board_Y] = 2;
    WhitePutCPU(Board_X, Board_Y);
    Board_X = 0;
    Board_Y = 0;
    ReturnNumMax = 0;
    return 1;
}